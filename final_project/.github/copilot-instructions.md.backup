# GitHub Copilot Instructions

## Overview
**Multi-Agent LLM Strategy Game** - AI agents use LLMs to create custom factions, design units, and compete strategically. Think Age of Empires III with AI agents as players.

## Architecture Quick Reference

### Key Systems
- **Agents** (`agents/`): BaseAgent → PlayerAgent/AdminAgent → LLMInterface for decisions
- **Abilities** (`abilities/`): Registry-based modular system (14 abilities: 8 unit, 6 building)
- **Game Engine** (`core/`): GameEngine processes actions → updates GameState → TurnManager
- **Entities** (`entities/`): Faction/Unit/Building with string-based abilities (Set[str])
- **Caching** (`.env` controlled): Faction/sprite caching to minimize API costs

### Critical Patterns
1. **Ability System (FULLY DYNAMIC)**:
   ```python
   # Abilities stored as strings, resolved at runtime
   unit.abilities: Set[str] = {"stealth", "charge"}
   
   # All descriptions auto-generated from registry
   from abilities import get_ability_descriptions, get_ability_list
   unit_desc = get_ability_descriptions("unit")  # Pulls from Ability.description
   
   # Adding new abilities (2 steps):
   # 1. Create class in abilities/unit_abilities.py inheriting Ability
   # 2. Register: ABILITY_REGISTRY.register("poison", PoisonAbility(), "unit")
   # That's it! Auto-appears in prompts/schemas/docs
   ```

2. **Agent Decision Flow**:
   ```python
   PlayerAgent.make_decision() → get_player_agent_system_prompt() (dynamic abilities)
   → LLMInterface.make_function_call() → AgentAction
   → GameEngine processes → GameState updated
   ```

3. **LLM Integration**:
   - System prompts: `config/llm_config.py` - `get_player_agent_system_prompt()` (dynamic)
   - Function schemas: `agents/function_schemas.py` - `_get_ability_info()` (dynamic)
   - All ability info pulled from registry - NO hardcoded lists

### Environment Config (.env)
```bash
OPENAI_API_KEY=your_key
FACTION_CACHE_ENABLED=true    # Use cached factions (dev mode)
SPRITE_CACHE_ENABLED=false    # Fresh sprites each time
CACHE_SAVE_ENABLED=true       # Save new generations
FACTION_CACHE_MODE=similar    # "exact", "similar", "random"
```

## Essential Code Patterns

### Ability Execution
```python
from abilities import ABILITY_REGISTRY, AbilityContext

context = AbilityContext(owner=unit, target=enemy, action_type="attack")
results = ABILITY_REGISTRY.execute_abilities(unit.abilities, context)
```

### Game State Views (Fog of War)
```python
# Agents only see filtered state
view = game_state.get_agent_view(agent_id)
# Stealth units hidden unless adjacent (distance ≤ 1)
```

### Dynamic Ability Documentation
```python
# For prompts
from abilities import get_ability_descriptions
prompt = f"Available abilities:\n{get_ability_descriptions('unit')}"

# For schemas
from abilities import get_ability_list, get_ability_enum_description
enum_values = get_ability_list("unit")  # ["stealth", "heal", ...]
description = get_ability_enum_description("unit")  # "stealth=Hidden, heal=Heals units"
```

## Testing
```bash
python tests/run_tests.py              # All mocked tests (free)
python tests/run_tests.py --real-llm  # Real LLM tests (costs $)
python tests/test_dynamic_abilities.py # Verify ability system
python main.py --demo                  # Full game demo
```

## Common Tasks

**Add New Ability**:
1. Create class in `abilities/unit_abilities.py` or `building_abilities.py`
2. Register in `abilities/__init__.py`: `ABILITY_REGISTRY.register("id", Class(), "unit")`
3. Done! No schema updates needed.

**Add Agent Action**:
1. Add function schema in `agents/function_schemas.py`
2. Add processor in `core/game_engine.py`: `self._register_action_processors()`
3. Update agent logic in `agents/player_agent.py`

**Debug LLM Issues**:
- Set `DEBUG_LLM_RESPONSES=true` in `.env`
- Check `LLMInterface.token_usage` for costs
- Use mocked tests before real LLM calls

## Key Files for Common Changes
- **Ability changes**: `abilities/*.py` (self-documenting system)
- **Agent behavior**: `agents/player_agent.py` (decision logic)
- **LLM prompts**: `config/llm_config.py` (dynamic prompt generation)
- **Function schemas**: `agents/function_schemas.py` (dynamic enum loading)
- **Game rules**: `core/game_engine.py` (action processing)

## Important Notes
- All factions/units/buildings are LLM-generated (no hard-coded content)
- Abilities use string IDs for extensibility (not enums)
- Stealth detection: hidden unless adjacent (≤1 tile)
- Fortify: only works if unit hasn't moved this turn
- Charge: only triggers if unit moved before attacking
- Game state views respect fog of war + stealth detection
    color_scheme: List[str]
    architectural_style: str
    unit_naming_convention: str

# entities/unit.py
@dataclass
class Unit:
    unit_type: str
    stats: UnitStats
    position: tuple
    faction_id: str
    abilities: Set[str]  # String-based ability IDs for flexibility

# entities/faction.py - Building class
@dataclass
class Building:
    building_type: str
    health: int
    produces_units: List[str]
    resource_generation: Dict[str, int]
    abilities: Set[str]  # Building abilities

# abilities/base.py
class Ability(ABC):
    def can_apply(context: AbilityContext) -> bool
    def apply(context: AbilityContext) -> Dict[str, Any]

class AbilityRegistry:
    def register(ability_id: str, ability: Ability, category: str)
    def get(ability_id: str) -> Optional[Ability]
    def execute_abilities(ability_ids: list, context: AbilityContext) -> Dict

# Global registry with all 14 abilities pre-registered
from abilities import ABILITY_REGISTRY

# sprites/generator.py
class SpriteGenerator:
    async def generate_faction_sprites(faction_data: Dict) -> Dict[str, Sprite]
```

#### Caching System
```python
# cache/faction_cache.py
class FactionCache:
    def get_similar_faction(personality: str, mode: str) -> Optional[CachedFaction]
    def store_faction(faction_data: CachedFaction)

# sprites/cache.py  
class SpriteCache:
    def get_sprite(cache_key: str) -> Optional[Sprite]
    def store_sprite(cache_key: str, sprite: Sprite)
```

## Architecture & Key Components

### Core Game Flow
1. **Setup Phase**: Agents create factions using `PlayerAgent._handle_faction_setup()` → LLM calls → `GameEngine.process_faction_creation()`
2. **Sprite Generation**: Custom units get visual sprites via `SpriteGenerator.generate_faction_sprites()`  
3. **Gameplay Phase**: Turn-based decisions through `PlayerAgent.make_decision()` → `TurnManager`
4. **State Management**: Centralized in `GameState` with agent-specific views via `get_agent_view()`

### Agent Architecture Pattern
All agents inherit from `BaseAgent` and use mixins:
```python
class PlayerAgent(BaseAgent, AgentPersonalityMixin, AgentMemoryMixin, AgentCommunicationMixin)
```
- **Function-based Actions**: Agents use structured LLM function calling via `LLMInterface.make_function_call()`
- **Personality System**: Each agent has predefined personality traits affecting strategy (see `config/llm_config.py`)
- **Action Pattern**: All agent decisions return `List[AgentAction]` with `action_type`, `parameters`, `reasoning`

### Caching Strategy (Critical for API Costs)
**Environment-controlled caching** via `.env` variables:
```bash
FACTION_CACHE_ENABLED=true     # Use cached faction data
SPRITE_CACHE_ENABLED=false     # Always generate fresh sprites  
CACHE_SAVE_ENABLED=true        # Save new generations to cache
FACTION_CACHE_MODE=similar     # "exact", "similar", "random"
```

**Cache Flow**: `PlayerAgent._try_load_cached_complete_faction()` → `FactionCache.get_similar_faction()` → Convert back to `AgentAction` objects

### LLM Integration Pattern
- **Structured Calls**: Use function schemas from `agents/function_schemas.py`
- **Response Handling**: All LLM calls return `LLMResponse` objects with `success`, `function_calls`, `error`
- **Cost Management**: Token usage tracked in `LLMInterface.token_usage`
- **Error Resilience**: Always check `response.success` before processing `function_calls`

## Development Workflows

### Running & Testing
```bash
# Main game
python main.py                                 # Full game
python main.py --demo                          # Demo mode

# Test suites  
python tests/run_tests.py                      # All mocked tests (free)
python tests/run_tests.py --real-llm          # Real LLM tests (costs $)
python tests/run_tests.py -m test_game_state  # Specific module
```

### Environment Setup
1. Copy `.env.example` → `.env` and add `OPENAI_API_KEY`
2. **Development**: Set `*_CACHE_ENABLED=true` to minimize costs
3. **Testing**: Set `CACHE_SAVE_ENABLED=false` to avoid polluting cache
4. **Production**: Set `*_CACHE_ENABLED=false` for fresh content

### Debugging LLM Issues
- Set `DEBUG_LLM_RESPONSES=true` in `.env` for full LLM call logging
- Check `LLMInterface.token_usage` for cost tracking
- Use mocked tests (`tests/test_llm_integration.py`) before expensive real tests

## Key Patterns & Conventions

### Agent Decision Making
```python
async def make_decision(self, game_state_view: Dict[str, Any]) -> List[AgentAction]:
    # 1. Analyze game phase
    phase = game_state_view.get("phase", "playing")
    
    # 2. Route to appropriate handler
    if phase == "setup":
        return await self._handle_faction_setup(game_state_view)
    else:
        return await self._handle_gameplay_turn(game_state_view)
```

### Function Schema Integration
- Function definitions in `agents/function_schemas.py` must match LLM capabilities
- Use `get_functions_for_phase()` to get appropriate functions per game phase
- Always validate function parameters in action processors

### Entity Relationship Pattern
```
GameState → Factions → Units/Buildings (with abilities)
         → Map (Tiles with visibility)
         → TurnManager
         → AbilityRegistry (global)
```
- **Factions** own units/buildings and have themes + custom unit/building designs
- **Units** have stats, positions, and string-based abilities (Set[str])
- **Buildings** have production capabilities and string-based abilities
- **Abilities** are resolved at runtime via ABILITY_REGISTRY
- **Game State** provides filtered views to agents (fog of war via `get_agent_view()`)
- **Visibility** accounts for stealth (units hidden unless adjacent)

### Ability System Architecture (CRITICAL)
```python
# Abilities are stored as strings, not enums
unit.abilities: Set[str] = {"stealth", "charge"}
building.abilities: Set[str] = {"auto_attack", "wall"}

# Runtime execution via global registry
from abilities import ABILITY_REGISTRY, AbilityContext

context = AbilityContext(owner=unit, target=enemy, action_type="attack")
results = ABILITY_REGISTRY.execute_abilities(unit.abilities, context)

# Abilities modify game state directly
for ability_id, effect in results["effects"].items():
    if "new_damage" in effect:
        damage = effect["new_damage"]
```

**14 Implemented Abilities:**
- **Unit (8)**: stealth, heal, build, gather, fortify, charge, range_attack, splash
- **Building (6)**: auto_attack, wall, heal_aura, resource_bonus, research, train_faster

**Key Files:**
- `abilities/base.py` - Ability, AbilityContext, AbilityRegistry
- `abilities/unit_abilities.py` - All unit ability implementations
- `abilities/building_abilities.py` - All building ability implementations
- `abilities/utils.py` - Dynamic description generation (get_ability_descriptions, get_ability_list, etc.)
- `abilities/__init__.py` - Global ABILITY_REGISTRY initialization + wrapper functions
- `abilities/README.md` - Complete developer guide for adding abilities

**Adding New Abilities (2 steps - fully automatic!):**
1. Create class in `abilities/unit_abilities.py` or `building_abilities.py` inheriting from `Ability`
2. Register in `abilities/__init__.py`: `ABILITY_REGISTRY.register("poison", PoisonAbility(), "unit")`

**That's it!** The ability will automatically appear in:
- Agent system prompts (via `get_player_agent_system_prompt()`)
- Function schemas (via `_get_ability_info()` in `function_schemas.py`)
- Design prompts (via `get_ability_descriptions()` in `player_agent.py`)
- No hardcoded lists to update!

### How Agents Learn About Abilities (DYNAMIC SYSTEM)

**All ability information is automatically pulled from the ability registry - no hardcoded lists!**

**During Faction Setup:**
Agents receive ability information through:
1. **System Prompt** (dynamically generated via `config/llm_config.py` - `get_player_agent_system_prompt()`):
   - Calls `get_ability_descriptions("unit")` and `get_ability_descriptions("building")`
   - Lists all abilities with effects pulled from `Ability.description` attribute
   - Example: "stealth: Hidden from enemies (50% detection range), must be adjacent to detect"

2. **Function Schema Descriptions** (dynamically generated via `agents/function_schemas.py`):
   - `_get_ability_info()` calls `get_ability_list()` and `get_ability_enum_description()`
   - `design_unit` schema enum auto-populated with all unit abilities
   - `design_building` schema enum auto-populated with all building abilities
   - Description field shows compact format: "stealth=Hidden from enemies, heal=Heals friendly units"

3. **Prompts During Design** (dynamically generated via `agents/player_agent.py`):
   - `_create_unit_designs()` calls `get_ability_descriptions("unit")`
   - Full ability list with effects inserted into prompt
   - Agents see complete descriptions from ability classes

**During Gameplay:**
Agents see abilities through `game_state.get_agent_view()`:
- Visible enemy units include `"abilities": ["charge", "stealth"]`
- Own units show full ability information
- Buildings show their abilities and resource generation
- Fortification status visible (`is_fortified` field)

**Dynamic Description Generation API:**
```python
from abilities import get_ability_descriptions, get_ability_list, get_ability_enum_description

# Get formatted descriptions for prompts
unit_desc = get_ability_descriptions("unit")  # "- stealth: Hidden from enemies...\n- heal: ..."
building_desc = get_ability_descriptions("building")

# Get ability IDs for schemas
unit_ids = get_ability_list("unit")  # ["stealth", "heal", "build", ...]
building_ids = get_ability_list("building")  # ["auto_attack", "wall", ...]

# Get compact descriptions for function schemas
compact = get_ability_enum_description("unit")  # "stealth=Hidden from enemies, heal=Heals friendly units"
```

**Ability Detection Logic:**
- **Stealth**: Hidden from sight unless within 1 tile (adjacent)
- Applied in `game_state._apply_stealth_detection()`
- **Fortify**: Only applies if unit hasn't moved this turn
- **Charge**: Only triggers if unit moved before attacking

### Sprite Generation Integration
- Custom units automatically get sprites via `SpriteGenerator` in setup phase
- Sprites cached separately from faction data using `SPRITE_CACHE_*` settings
- ASCII art generation with 16x16 pixel grids and color palettes

## Data Flow Examples

**Faction Creation**: `PlayerAgent._create_faction()` → LLM call with `create_faction` function → `AgentAction` → `GameEngine._process_create_faction()` → `Faction` object in `GameState`

**Unit Design**: `PlayerAgent._create_unit_designs()` → LLM calls with `design_unit` function → `AgentAction` → `GameEngine._process_design_unit()` → `Faction.custom_unit_designs`

**Sprite Pipeline**: `SpriteGenerator.generate_faction_sprites()` → Extract custom unit data → LLM sprite generation → `Sprite` objects with pixel data

## Critical Files to Understand
- `agents/base_agent.py` - Agent interface and action pattern
- `agents/player_agent.py` - Main AI player logic and caching
- `core/game_engine.py` - Action processing and game state updates  
- `agents/function_schemas.py` - LLM function definitions
- `config/game_config.py` - Environment-based configuration
- `sprites/generator.py` - LLM-based sprite generation with caching

## Common Gotchas
- **LLM Costs**: Always use caching in development, disable for fresh content
- **Async Patterns**: Agent decisions are async, use proper `await` handling
- **Function Validation**: LLM responses may have invalid function parameters, always validate
- **Game State Views**: Agents only see filtered game state, not full state
- **Action Processing**: Actions must be processed through `GameEngine` to update state
- **Ability Strings**: Abilities are stored as strings (`Set[str]`), not enums, for flexibility
- **Stealth Detection**: Stealth units are hidden from enemies unless adjacent (distance ≤ 1)
- **Ability Context**: Pass `game_state` to `unit.attack()` for full ability support

## Testing Ability System
```python
# Test ability execution
from abilities import ABILITY_REGISTRY, AbilityContext

unit = Unit(abilities={"charge"})
context = AbilityContext(owner=unit, target=enemy, action_type="attack", base_damage=10)
results = ABILITY_REGISTRY.execute_abilities(["charge"], context)

# Verify ability was applied
assert "charge" in results["applied"]
assert results["effects"]["charge"]["new_damage"] > 10  # Charge bonus applied
```

**Test Files:**
- `tests/test_ability_integration.py` - Integration tests for all abilities
- `tests/test_entities.py` - Unit/building tests with abilities
- `tests/run_tests.py` - Comprehensive test runner